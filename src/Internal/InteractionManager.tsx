import * as React from 'react';
import * as THREE from 'three';
import { connect } from 'react-redux'
import { RouteComponentProps } from 'react-router-dom';
import * as Hammer from 'hammerjs'
import BrowserDetect from '../../../lib/BrowserDetect'

import ThreeScene from '../ThreeScene'
import ThreeObject from '../ThreeObject'
import * as Interaction from '../ThreeInteraction'
import Raycaster from './Raycaster'

const CLICK_DELAY_MS = 500;
const CLICK_MOVEMENT_LIMIT = 10;
const SCROLL_FRICTION = -0.05;

const MOZ_SOURCE_UNKNOWN = 0;   // The input device is unknown.
const MOZ_SOURCE_MOUSE = 1;     // The event was generated by a mouse (or mouse- like device).
const MOZ_SOURCE_PEN = 2;       // The event was generated by a pen on a tablet.
const MOZ_SOURCE_ERASER = 3;    // The event was generated by an eraser on a tablet.
const MOZ_SOURCE_CURSOR = 4;    // The event was generated by a cursor.
const MOZ_SOURCE_TOUCH = 5;     // The event was generated on a touch interface.
const MOZ_SOURCE_KEYBOARD = 6;  // The event was generated by a keyboard.

// Note: HammerJS supports only mouse/pointer events generated by left mouse button, touch adn pen.
//       We will use those constants to clone and stamp right/middle button click events that we will
//       inject into HammerJS for processing.
const MY_HACK_BUTTON = 'MY_HACK_BUTTON';
const MY_HACK_BUTTONS = 'MY_HACK_BUTTONS';

let emptyIntersection: THREE.Intersection;

type InteractionCallback = () => void;

export module Internal {
    export class InteractionManager {
        private m_scene: ThreeScene;
        private m_raycaster: Raycaster;
        private m_target: HTMLElement;
        private m_hammer: HammerManager;
        private m_initialized: boolean;
        private m_onInteraction?: InteractionCallback | null;

        private m_current: {
            hover: boolean;
            buttons: number;
            capturing: boolean;
            manipulation: boolean;
            intersection: Interaction.IThreeIntersection;
            type: Interaction.PointerDeviceType;
        };
        private m_currentClickState: {
            uuid: string;
            timer: number;
        }

        // #region Misc
        private m_ignoreMouseMove: number;
        private m_mozPointerOutTimer: number;
        private m_initialScroll: THREE.Vector2;
        // #endregion

        // #region Focused scene object
        private m_lastViewportPosition: THREE.Vector2;
        private get lastViewportPosition(): THREE.Vector2 | null {
            return this.m_lastViewportPosition;
        }
        private set lastViewportPosition(value: THREE.Vector2 | null) {
            if (value) {
                this.m_lastViewportPosition = value;
            } else {
                if (this.m_lastViewportPosition) {
                    delete this.m_lastViewportPosition;
                }
            }
        }
        private m_lastViewportPositionHandled: boolean;
        // #endregion

        // #region Focused scene object
        private m_focusedComponent: ThreeObject<any, any>;
        private get focusedComponent(): ThreeObject<any, any> | null {
            return this.m_focusedComponent;
        }
        private set focusedComponent(value: ThreeObject<any, any> | null) {
            if (value !== this.m_focusedComponent) {
                // Remove focus first
                if (this.m_focusedComponent) {
                    asListener(this.m_focusedComponent).OnLostFocus();
                    delete this.m_focusedComponent;
                }

                // Set new focus
                if (value) {
                    this.m_focusedComponent = value;
                    asListener(this.m_focusedComponent).OnGotFocus();
                }
            }
        }
        // #endregion

        // #region Event args allocations
        private readonly m_pointerEvent: PointerEventImpl = new PointerEventImpl();
        private readonly m_manipulationEvent: ManipulationEventImpl = new ManipulationEventImpl(this.m_pointerEvent);
        // #endregion

        constructor() {
            this.m_currentClickState = {
                uuid: '',
                timer: 0
            }

            this.onInputHandler = this.onInputHandler.bind(this);

            this.onMouseDownHandlerHack = this.onMouseDownHandlerHack.bind(this);
            this.onMouseMoveHandlerHack = this.onMouseMoveHandlerHack.bind(this);
            this.onMouseUpHandlerHack = this.onMouseUpHandlerHack.bind(this);

            this.onMouseOverHandler = this.onMouseOverHandler.bind(this);
            this.onMouseOutHandler = this.onMouseOutHandler.bind(this);
            this.onTouchEndHandler = this.onTouchEndHandler.bind(this);
            this.onContextMenuHandler = this.onContextMenuHandler.bind(this);

            this.onPanStart = this.onPanStart.bind(this);
            this.onPanMove = this.onPanMove.bind(this);
            this.onPanEnd = this.onPanEnd.bind(this);
            this.onPanCancel = this.onPanCancel.bind(this);

            this.onPinchStart = this.onPinchStart.bind(this);
            this.onPinchMove = this.onPinchMove.bind(this);
            this.onPinchEnd = this.onPinchEnd.bind(this);
            this.onPinchCancel = this.onPinchCancel.bind(this);

            this.onRotateStart = this.onRotateStart.bind(this);
            this.onRotateMove = this.onRotateMove.bind(this);
            this.onRotateEnd = this.onRotateEnd.bind(this);
            this.onRotateCancel = this.onRotateCancel.bind(this);

            this.onTap = this.onTap.bind(this);
            this.onLongPress = this.onLongPress.bind(this);
        }
        public initialize(scene: ThreeScene) {
            this.m_scene = scene;
            this.m_raycaster = scene.raycaster as Raycaster;
            this.m_initialized = true;
        }
        public uninitialize() {
            this.m_initialized = false;
            if (this.m_scene) {
                delete this.m_scene;
            }
            if (this.m_raycaster) {
                delete this.m_raycaster;
            }
        }
        public dispose(): void {
            this.uninitialize();
            this.disconnectEvents();
        }

        public get onInteraction(): InteractionCallback | null | undefined {
            return this.m_onInteraction;
        }
        public set onInteraction(callback: InteractionCallback | null | undefined) {
            this.m_onInteraction = callback;
        }

        public update(): void {
            if (this.m_initialized && this.m_lastViewportPosition) {
                if (!this.m_lastViewportPositionHandled) {
                    this.processUpdate();
                } else {
                    this.m_lastViewportPositionHandled = false;
                }
            }
        }

        public connectEvents(domElement: HTMLElement) {
            if (this.m_target == domElement) {
                return;
            }

            this.disconnectHoverEvents();

            this.m_target = domElement;

            // Mouse/Pointer event handlers to inject events triggered by right/middle buttons (not supported by HammerJS natively)
            this.m_target.addEventListener('pointerdown', this.onMouseDownHandlerHack, false);
            this.m_target.addEventListener('pointermove', this.onMouseMoveHandlerHack, false);
            this.m_target.addEventListener('pointerup', this.onMouseUpHandlerHack, false);
            this.m_target.addEventListener('mousedown', this.onMouseDownHandlerHack, false);
            this.m_target.addEventListener('mousemove', this.onMouseMoveHandlerHack, false);
            this.m_target.addEventListener('mouseup', this.onMouseUpHandlerHack, false);

            // Mouse events that listen to hover and initial mouse press (other events are added later on-demand)
            this.m_target.addEventListener('mousemove', this.onMouseOverHandler, false);
            this.m_target.addEventListener('mouseout', this.onMouseOutHandler, false);
            this.m_target.addEventListener('touchend', this.onTouchEndHandler, false);
            this.m_target.addEventListener('contextmenu', this.onContextMenuHandler, false);

            // Set up gesture recognition handlers
            if (this.m_hammer) {
                this.m_hammer.set({ inputTarget: this.m_target });
            } else {
                let options: HammerOptions | undefined;

                // Note: Bug in PointerEvents handling with touch on Chrome browsers:
                //       StackOverflow description: https://stackoverflow.com/questions/48743574/android-pointer-events-coordinates
                //                                  https://stackoverflow.com/questions/48766269/wrong-coordinate-in-android-chrome-pointer-event
                //       Bug report: https://bugs.chromium.org/p/chromium/issues/detail?id=811715
                //       Bug fix: https://chromium-review.googlesource.com/c/chromium/src/+/914690
                //       Included in: https://chromium-review.googlesource.com/c/chromium/src/+/914690
                if (BrowserDetect.isChrome) {
                    let version = BrowserDetect.version;
                    if (version && version.length > 2 && !(version[0] >= 66 && version[1] >= 0 && version[2] >= 3348)) {
                        const SUPPORT_TOUCH_INPUT = ('ontouchstart' in window);
                        options = {
                            inputClass: (SUPPORT_TOUCH_INPUT ? Hammer.TouchInput : Hammer.MouseInput)
                        };
                    }
                }

                this.m_hammer = new Hammer.Manager(this.m_target, options);
                this.m_hammer.on('hammer.input', this.onInputHandler);

                this.m_hammer.add(new Hammer.Pan({ threshold: 0, pointers: 0 }));
                this.m_hammer.on('panstart', this.onPanStart);
                this.m_hammer.on('panmove', this.onPanMove);
                this.m_hammer.on('panend', this.onPanEnd);
                this.m_hammer.on('pancancel', this.onPanCancel);

                this.m_hammer.add(new Hammer.Pinch({ threshold: 0 }))
                    .recognizeWith(this.m_hammer.get('pan'))
                this.m_hammer.on('pinchstart', this.onPinchStart);
                this.m_hammer.on('pinchmove', this.onPinchMove);
                this.m_hammer.on('pinchend', this.onPinchEnd);
                this.m_hammer.on('pinchcancel', this.onPinchCancel);

                this.m_hammer.add(new Hammer.Rotate({ threshold: 0 }))
                    .recognizeWith(this.m_hammer.get('pan'))
                    .recognizeWith(this.m_hammer.get('pinch'));
                this.m_hammer.on('rotatestart', this.onRotateStart);
                this.m_hammer.on('rotatemove', this.onRotateMove);
                this.m_hammer.on('rotateend', this.onRotateEnd);
                this.m_hammer.on('rotatecancel', this.onRotateCancel);

                this.m_hammer.add(new Hammer.Tap({ time: 600 }))
                    .recognizeWith(this.m_hammer.get('pan'));
                this.m_hammer.add(new Hammer.Press({ time: 700 }))
                    .recognizeWith(this.m_hammer.get('pan'));
                this.m_hammer.on("tap", this.onTap);
                this.m_hammer.on("press pressup", this.onLongPress);

                if ((this.m_hammer as any).input.constructor.name !== (Hammer.MouseInput as any).prototype.constructor.name) {
                    this.m_target.removeEventListener('mousedown', this.onMouseDownHandlerHack, false);
                    this.m_target.removeEventListener('mousemove', this.onMouseMoveHandlerHack, false);
                    this.m_target.removeEventListener('mouseup', this.onMouseUpHandlerHack, false);
                }

                if ((this.m_hammer as any).input.constructor.name !== (Hammer.PointerEventInput as any).prototype.constructor.name) {
                    this.m_target.removeEventListener('pointerdown', this.onMouseDownHandlerHack, false);
                    this.m_target.removeEventListener('pointermove', this.onMouseMoveHandlerHack, false);
                    this.m_target.removeEventListener('pointerup', this.onMouseUpHandlerHack, false);
                }
            }
        }
        public disconnectEvents() {
            this.disconnectHoverEvents();

            if (this.m_hammer) {
                this.m_hammer.destroy();
                delete this.m_hammer;
            }
        }
        private disconnectHoverEvents() {
            if (this.m_target) {
                // Disconnect hack mouse events
                this.m_target.removeEventListener('pointerdown', this.onMouseDownHandlerHack, false);
                this.m_target.removeEventListener('pointermove', this.onMouseMoveHandlerHack, false);
                this.m_target.removeEventListener('pointerup', this.onMouseUpHandlerHack, false);
                this.m_target.removeEventListener('mousedown', this.onMouseDownHandlerHack, false);
                this.m_target.removeEventListener('mousemove', this.onMouseMoveHandlerHack, false);
                this.m_target.removeEventListener('mouseup', this.onMouseUpHandlerHack, false);

                // Disconnect hover mouse events
                this.m_target.removeEventListener('mousemove', this.onMouseOverHandler, false);
                this.m_target.removeEventListener('mouseout', this.onMouseOutHandler, false);
                this.m_target.removeEventListener('touchend', this.onTouchEndHandler, false);
                this.m_target.removeEventListener('contextmenu', this.onContextMenuHandler, false);
                delete this.m_target;
            }
        }

        private onInputHandler(e: HammerInput): void {
            if (!this.m_initialized) {
                return;
            }

            let target = (e.srcEvent.currentTarget || e.target) as Element;
            let viewportPosition = InteractionManager.getPosition(e);
            this.updateDeviceType(e);

            if (e.isFirst) {
                // Update hover state
                var cancel = false;
                var result = this.processUpdate(viewportPosition, e);
                if (result && this.m_current && this.m_current.hover) {
                    // Set focus to the current component
                    this.focusedComponent = this.m_current.intersection.component;

                    // Capture pointer events for the current component
                    if (!this.m_current.capturing) {
                        cancel = !this.pointerPress(e);
                    }
                } else {
                    cancel = true;
                }

                if (cancel) {
                    this.pointerCancelCapture();
                    this.pointerGone();
                    // Clear focus
                    this.focusedComponent = null;
                    // Stop gesture recognition
                    this.m_hammer.stop(true);
                    // Inisialize scrolling state
                    this.beginScroll();
                }
            } else if (e.isFinal) {
                // CLear scrolling state
                this.endScroll();

                // Release captured pointer
                this.processUpdate(viewportPosition, e);
                if (this.m_current && this.m_current.capturing) {
                    this.pointerRelease();
                }

                // If released outside viewport then clear current position
                if (!InteractionManager.isWithinClientBounds(viewportPosition) ||
                    InteractionManager.isTouchPointerType(e)) {
                    // Handle tap gesture manually
                    this.m_hammer.get('tap').recognize(e);
                    // Clear pointer info
                    this.pointerGone();
                }
            } else if (this.m_current) {
                // Update component that is capturing pointer events
                this.processUpdate(viewportPosition, e);
            } else {
                // Update scrolling state
                this.updateScroll(e);
            }

            if (this.m_mozPointerOutTimer) {
                window.clearTimeout(this.m_mozPointerOutTimer);
                delete this.m_mozPointerOutTimer;
            }

            if (this.m_onInteraction) {
                this.m_onInteraction();
            }
        }

        // #region Gesture handlers
        private onPanStart(e: HammerInput): void {
            this.startManipulation(e);
        }
        private onPanMove(e: HammerInput): void {
            this.updateManipulation(e);
        }
        private onPanEnd(e: HammerInput): void {
            this.endManipulation();
        }
        private onPanCancel(e: HammerInput): void {
            return this.onPanEnd(e);
        }

        private onPinchStart(e: HammerInput): void {
            this.startManipulation(e);
        }
        private onPinchMove(e: HammerInput): void {
            this.updateManipulation(e);
        }
        private onPinchEnd(e: HammerInput): void {
            this.endManipulation();
        }
        private onPinchCancel(e: HammerInput): void {
            return this.onPinchEnd(e);
        }

        private onRotateStart(e: HammerInput): void {
            this.startManipulation(e);
        }
        private onRotateMove(e: HammerInput): void {
            this.updateManipulation(e);
        }
        private onRotateEnd(e: HammerInput): void {
            this.endManipulation();
        }
        private onRotateCancel(e: HammerInput): void {
            return this.onRotateEnd(e);
        }

        private onTap(e: HammerInput): void {
            if (this.m_current) {
                // Stop click count reset timer
                if (this.m_currentClickState.timer) {
                    window.clearTimeout(this.m_currentClickState.timer);
                }
                // Verify click target
                if (this.m_current.intersection.object.uuid != this.m_currentClickState.uuid) {
                    this.m_pointerEvent.resetClickCount();
                    this.m_currentClickState.uuid = this.m_current.intersection.object.uuid;
                }
                // Dispatch click event
                this.m_pointerEvent.incrementClickCount();
                this.updateEventArgs();
                getListener(this.m_current.intersection).OnClick(this.m_pointerEvent);
                // Start click count reset timer
                this.m_currentClickState.timer = window.setTimeout(() => {
                    if (this.m_currentClickState) {
                        delete this.m_currentClickState.uuid;
                        delete this.m_currentClickState.timer;
                    }
                }, 600);

                this.invokeCallback();
            }
        }
        private onLongPress(e: HammerInput): void {
            if (this.m_current) {
                // Dispatch long press event
                this.updateEventArgs();
                getListener(this.m_current.intersection).OnLongPress(this.m_pointerEvent);

                this.invokeCallback();
            }
        }
        // #endregion

        // #region Hover event handlers
        private onMouseOverHandler(e: MouseEvent) {
            if (!this.m_initialized) {
                return;
            }

            // Note: This handles only hover gesture.
            //       Ignore if any button is pressed.
            if (e.buttons) {
                return;
            }

            // Note: https://stackoverflow.com/questions/14486804/understanding-touch-events/39477086#39477086
            //  MouseMove for Touch/Pen click/tap events will be raised right after 'pointerleave'
            //  which may cause 'hover' state on pointer events that do not support hover.
            //  Ignore all touch-capable 'mouseover' events.
            let caps = (e as any).sourceCapabilities;
            if (this.m_ignoreMouseMove ||
                caps && caps.firesTouchEvents ||
                (e as any).mozInputSource == MOZ_SOURCE_TOUCH) {
                this.pointerGone();
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }

            // Note: If this event fires on Mozilla browser and stylus was used then 
            //       start a timer that simulates pointerout when it times out.
            //       Platform bug/side-effect on Windows 10.
            if ((e as any).mozInputSource == MOZ_SOURCE_PEN) {
                if (this.m_mozPointerOutTimer) {
                    window.clearTimeout(this.m_mozPointerOutTimer);
                }
                this.m_mozPointerOutTimer = window.setTimeout(() => {
                    this.pointerGone();
                    if (this.m_mozPointerOutTimer) {
                        delete this.m_mozPointerOutTimer;
                    }
                }, 2000);
            }

            // Finally handler hover gesture update
            let target = (e.currentTarget || e.target) as Element;
            let viewportPosition = InteractionManager.getMousePosition(e, target);
            this.updateDeviceType(e);

            if (this.processUpdate(viewportPosition)) {
                this.invokeCallback();
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }
        private onMouseOutHandler(e: MouseEvent) {
            if (!this.m_initialized) {
                return;
            }

            this.updateDeviceType(e);
            if (this.pointerGone()) {
                this.invokeCallback();
                e.preventDefault();
                e.stopPropagation();
                return false;
            }
        }
        private onTouchEndHandler(e: TouchEvent) {
            if (!this.m_initialized) {
                return;
            }

            if (this.m_ignoreMouseMove) {
                window.clearTimeout(this.m_ignoreMouseMove);
            }
            this.m_ignoreMouseMove = window.setTimeout(() => {
                if (this.m_ignoreMouseMove) {
                    delete this.m_ignoreMouseMove;
                }
            }, 250);
        }
        private onContextMenuHandler(e: MouseEvent) {
            e.stopImmediatePropagation();
            e.stopPropagation();
            e.preventDefault();
            return false;
        }
        // #endregion

        // #region Right/middle button hack
        // Note: Prevents this events to be sent to HammerJS
        //       We have a temporary right/middle button handling
        //       until HammerJS supports it natively.
        private onMouseDownHandlerHack(e: MouseEvent | PointerEvent) {
            if (e.buttons > 1) {
                var clonedEvent = InteractionManager.cloneMouseEvent(e);
                if (clonedEvent) {
                    (this.m_hammer as any).input.domHandler(clonedEvent);
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                }
            }
        }
        private onMouseUpHandlerHack(e: MouseEvent | PointerEvent) {
            if (e.buttons > 1) {
                var clonedEvent = InteractionManager.cloneMouseEvent(e);
                if (clonedEvent) {
                    (this.m_hammer as any).input.domHandler(clonedEvent);
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                }
            }
        }
        private onMouseMoveHandlerHack(e: MouseEvent | PointerEvent) {
            if (e.buttons > 1) {
                var clonedEvent = InteractionManager.cloneMouseEvent(e);
                if (clonedEvent) {
                    (this.m_hammer as any).input.domHandler(clonedEvent);
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                    e.preventDefault();
                    return false;
                }
            }
        }
        // #endregion

        // #region Page scroll
        private beginScroll() {
            // Save initial page scroll
            this.m_initialScroll = new THREE.Vector2(
                window.pageXOffset,
                window.pageYOffset);
        }
        private updateScroll(e: HammerInput) {
            if (this.m_initialScroll) {
                // Simulate page scroll with touch/pen since browser won't do it for us
                if (InteractionManager.isTouchPointerType(e)) {
                    let x = this.m_initialScroll.x - e.deltaX;
                    let y = this.m_initialScroll.y - e.deltaY;
                    window.scroll(x, y);
                }
            }
        }
        private endScroll() {
            // Reset page scrolling info
            if (this.m_initialScroll) {
                delete this.m_initialScroll;
            }
        }
        // #endregion

        // #region Updating state
        private processUpdate(viewportPosition?: THREE.Vector2, e?: HammerInput): boolean {
            let result = false;

            // Do not proceed if pointer isn't captured and we are outside of the viewport
            if (viewportPosition && !InteractionManager.isWithinClientBounds(viewportPosition)) {
                result = this.pointerGone();
            }

            // Update hover state
            if (!result || this.m_current) {
                result = this.processHover(viewportPosition, e);
            }

            // Send exit to component that captures pointer events
            if (!result && this.m_current) {
                result = this.pointerExit();
            }

            this.invokeCallback();
            return result;
        }
        private processHover(viewportPosition?: THREE.Vector2, e?: HammerInput): boolean {
            // Update viewport positions
            let oldViewportPosition = this.m_lastViewportPosition;
            if (viewportPosition) {
                this.m_lastViewportPosition = viewportPosition;
                this.m_lastViewportPositionHandled = true;
            }

            // If current and capturing then we can skip raycasting
            if (this.m_current && this.m_current.capturing) {
                if (this.updateCurrentIntersection(this.m_lastViewportPosition)) {
                    // Intersection changed so let's notify the listener
                    var result = this.pointerMove();
                    // Dispatch OnPointerEnter() if listener isn't in a hover state.
                    if (!this.m_current.hover) {
                        result = this.pointerEnter(this.m_current.intersection, e) || result;
                    }
                    return result;
                } else if (!oldViewportPosition || oldViewportPosition.x != this.m_lastViewportPosition.x || oldViewportPosition.y != this.m_lastViewportPosition.y) {
                    // No intersection found but pointer has moved
                    var result = this.pointerMove(null);
                    // Dispatch OnPointerEnter() if listener is in a hover state.
                    if (this.m_current.hover) {
                        result = this.pointerExit() || result;
                    }
                    return result;
                } else {
                    // We are capturing so we stay silent for now
                    return false;
                }
            } else {
                var iterator = this.m_raycaster.raycast(this.m_lastViewportPosition);
                return forEach(iterator, (i: Interaction.IThreeIntersection): boolean => {
                    if (this.m_current) {
                        if (this.m_current.intersection.component != i.component) {
                            this.pointerExit();
                        } else if (!this.m_current.hover) {
                            return this.pointerEnter(i, e);
                        } else {
                            return this.pointerMove(i);
                        }
                    }

                    if (!this.m_current) {
                        return this.pointerEnter(i, e);
                    }

                    return false;
                });
            }
        }
        private pointerGone(): boolean {
            if (!this.m_current || !this.m_current.capturing) {
                // Delete last remembered pos to prevent OnUpdate() to happen.
                if (this.m_lastViewportPosition) {
                    delete this.m_lastViewportPosition;
                }

                // Send exit to component that captured pointer events
                if (this.m_current) {
                    this.pointerExit()
                }

                return true;
            }

            return true;
        }
        // #endregion

        // #region Dispatching pointer events
        private pointerEnter(i: Interaction.IThreeIntersection, e?: HammerInput): boolean {
            this.updateEventArgs(i);
            getListener(i).OnPointerEnter(this.m_pointerEvent);
            this.m_current = {
                hover: true,
                buttons: this.m_current ? this.m_current.buttons : 0,
                capturing: this.m_current ? this.m_current.capturing : false,
                manipulation: this.m_current ? this.m_current.manipulation : false,
                intersection: i,
                type: e ? InteractionManager.getDeviceType(e) : Interaction.PointerDeviceType.Mouse
            };

            this.invokeCallback();
            return true;
        }
        private pointerExit(): boolean {
            var result = false;

            // Send exit if haven't done this already
            if (this.m_current.hover) {
                this.updateEventArgs(null);
                getListener(this.m_current.intersection).OnPointerExit(this.m_pointerEvent);
                this.m_current.hover = false;
                result = true;
            }

            // Update current info
            if (!this.m_current.capturing) {
                this.clearCurrent();
            }

            this.invokeCallback();
            return result;
        }
        private pointerMove(i?: Interaction.IThreeIntersection | null): boolean {
            var currentIntersection = this.m_current.intersection;
            if (i == null /* null || undefined */
                || !i.point.equals(currentIntersection.point)
                || i.distance != currentIntersection.distance
                || i.distanceToRay != currentIntersection.distanceToRay
                || i.index != currentIntersection.index
                || i.faceIndex != currentIntersection.faceIndex
                || i.face != currentIntersection.face) {

                // Send pointer moved (optionally update current intersection)
                if (i) { this.m_current.intersection = i; }
                this.updateEventArgs(i);
                getListener(this.m_current.intersection).OnPointerMove(this.m_pointerEvent);
            }

            this.invokeCallback();
            return true;
        }
        private pointerPress(e: HammerInput): boolean {
            var result = false;

            this.m_current.buttons = (e.srcEvent as any)['MY_HACK_BUTTONS'] || (e.srcEvent as any).buttons || 0;
            this.m_current.capturing = true;
            this.updateEventArgs();
            getListener(this.m_current.intersection).OnPointerPress(this.m_pointerEvent);
            if (this.m_pointerEvent.handled) {
                result = true;
            }

            this.invokeCallback();
            return result;
        }
        private pointerRelease(): void {
            // Send pointer release
            this.m_current.buttons = 0;
            this.updateEventArgs(this.m_current.hover ? undefined : null);
            getListener(this.m_current.intersection).OnPointerRelease(this.m_pointerEvent);
            this.pointerCancelCapture();
            this.invokeCallback();
        }
        private pointerCancelCapture() {
            if (this.m_current) {
                // Reset pointer capture flag
                if (this.m_current.capturing) {
                    this.m_current.capturing = false;
                    this.updateEventArgs(this.m_current.hover ? undefined : null);
                    getListener(this.m_current.intersection).OnPointerCaptureLost(this.m_pointerEvent);
                }

                // Update current info
                if (!this.m_current.hover) {
                    this.clearCurrent();
                }
            }
        }
        private clearCurrent() {
            this.endManipulation();
            delete this.m_current;
        }
        // #endregion

        // #region Dispatching manipulation events
        private startManipulation(e: HammerInput) {
            if (this.m_current && !this.m_current.manipulation) {
                let viewportPosition = InteractionManager.getPosition(e);
                this.m_manipulationEvent.initialize(e, viewportPosition);
                getListener(this.m_current.intersection).OnManipulationStart(this.m_manipulationEvent);
                this.m_current.manipulation = true;
                if (this.m_manipulationEvent.cancel) {
                    this.endManipulation();
                }
                this.invokeCallback();
            }
        }
        private updateManipulation(e: HammerInput) {
            if (this.m_current && this.m_current.manipulation) {
                // Skip manipulation update if nothing has changed
                let viewportPosition = InteractionManager.getPosition(e);
                if (this.m_manipulationEvent.changed(e, viewportPosition)) {
                    this.m_manipulationEvent.update(e, viewportPosition);
                    getListener(this.m_current.intersection).OnManipulationDelta(this.m_manipulationEvent);
                    if (this.m_manipulationEvent.cancel) {
                        this.endManipulation();
                    }
                    this.invokeCallback();
                }
            }
        }
        private endManipulation() {
            if (this.m_current && this.m_current.manipulation) {
                // this.m_manipulationEnd = {};
                getListener(this.m_current.intersection).OnManipulationEnd(this.m_manipulationEvent);
                this.m_current.manipulation = false;
                this.invokeCallback();
            }
        }
        // #endregion

        // #region Helper methods
        private updateCurrentIntersection(viewportPosition: THREE.Vector2): boolean {
            let intersection = this.m_raycaster.raycast(viewportPosition, this.m_current.intersection.object);
            if (intersection) {
                this.m_current.intersection = intersection;
                return true;
            }

            return false;
        }
        private updateDeviceType(e: HammerInput | MouseEvent): void {
            let args = this.m_pointerEvent;

            if ((e as any).initMouseEvent) {
                args.type = Interaction.PointerDeviceType.Mouse;

                if (this.m_current && this.m_current.capturing) {
                    args.properties.buttons = Interaction.MouseButton.Left;
                }
            } else {
                args.type = InteractionManager.getDeviceType(e as HammerInput);
            }

            switch (args.type) {
                case Interaction.PointerDeviceType.Mouse:
                    if (this.m_current) {
                        switch (this.m_current.buttons) {
                            case 1:
                                args.properties.buttons = Interaction.MouseButton.Left;
                                break;
                            case 2:
                                args.properties.buttons = Interaction.MouseButton.Right;
                                break;
                            case 4:
                                args.properties.buttons = Interaction.MouseButton.Middle;
                                break;
                        }
                    }
                    break;
                case Interaction.PointerDeviceType.Pen:
                    args.properties.isInContact = this.m_current ? this.m_current.capturing : false;
                    break;
            }
        }
        private updateEventArgs(i?: Interaction.IThreeIntersection | null): void {
            let args = this.m_pointerEvent;
            args.capturing = this.m_current ? this.m_current.capturing : false;
            args.position = this.m_lastViewportPosition;
            args.handled = false;

            if (i === null) {
                delete args.intersection;
            } else {
                args.intersection = (i ? i : this.m_current.intersection);
            }
        }
        private invokeCallback() {
            if (this.m_onInteraction) {
                this.m_onInteraction();
            }
        }

        private static getPosition(e: HammerInput): THREE.Vector2 {
            let target = e.target as HTMLElement;
            var rect = target.getBoundingClientRect();
            var client = e.center;
            var offsetX = (client.x - rect.left) / rect.width * 2.0 - 1.0;
            var offsetY = 1.0 - (client.y - rect.top) / rect.height * 2.0;
            return new THREE.Vector2(offsetX, offsetY);
        }
        private static getMousePosition(e: MouseEvent, target: Element): THREE.Vector2 {
            var rect = target.getBoundingClientRect();
            var offsetX = (e.clientX - rect.left) / rect.width * 2.0 - 1.0;
            var offsetY = 1.0 - (e.clientY - rect.top) / rect.height * 2.0;
            return new THREE.Vector2(offsetX, offsetY);
        }
        private static getDeviceType(e: HammerInput): Interaction.PointerDeviceType {
            switch (e.pointerType) {
                case 'mouse':
                    return Interaction.PointerDeviceType.Mouse;
                case 'touch':
                    return Interaction.PointerDeviceType.Touch;
                case 'pen':
                    return Interaction.PointerDeviceType.Pen;
                default:
                    return Interaction.PointerDeviceType.Other;
            }
        }
        private static isWithinClientBounds(vp: THREE.Vector2): boolean {
            return !(vp.x < -1.0 || vp.y < -1.0 || vp.x > 1.0 || vp.y > 1.0);
        }
        private static isTouchPointerType(e: HammerInput): boolean {
            return (e.pointerType == 'touch' || e.pointerType == 'pen');
        }

        private static cloneMouseEvent(e: MouseEvent | PointerEvent) {
            let evt: MouseEvent | PointerEvent | undefined;
            if (e instanceof PointerEvent) {
                let ptrEvt = new PointerEvent(e.type, {
                    bubbles: e.bubbles,
                    cancelable: e.cancelable,
                    view: e.view,
                    detail: e.detail,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    ctrlKey: e.ctrlKey,
                    altKey: e.altKey,
                    shiftKey: e.shiftKey,
                    metaKey: e.metaKey,
                    button: 0,
                    buttons: 0,
                    relatedTarget: e.relatedTarget,
                    width: e.width,
                    height: e.height,
                    pressure: e.pressure,
                    tiltX: e.tiltX,
                    tiltY: e.tiltY,
                    pointerId: e.pointerId,
                    pointerType: e.pointerType,
                    isPrimary: e.isPrimary
                });
                if (ptrEvt.initPointerEvent) {
                    ptrEvt.initPointerEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, e.relatedTarget, e.offsetX, e.offsetY, e.width, e.height, e.pressure, e.rotation, e.tiltX, e.tiltY, e.pointerId, e.pointerType, e.hwTimestamp, e.isPrimary);
                }
                evt = ptrEvt;
            } else if (e instanceof MouseEvent) {
                let mouseEvt = new MouseEvent(e.type, {
                    bubbles: e.bubbles,
                    cancelable: e.cancelable,
                    view: e.view,
                    detail: e.detail,
                    screenX: e.screenX,
                    screenY: e.screenY,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    ctrlKey: e.ctrlKey,
                    altKey: e.altKey,
                    shiftKey: e.shiftKey,
                    metaKey: e.metaKey,
                    button: 0,
                    buttons: 0,
                    relatedTarget: e.relatedTarget
                });
                if (mouseEvt.initMouseEvent) {
                    mouseEvt.initMouseEvent(e.type, e.bubbles, e.cancelable, e.view, e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, e.relatedTarget);
                }
                evt = mouseEvt;
            }

            if (evt) {
                Object.assign(evt, { MY_HACK_BUTTON: e.button });
                Object.assign(evt, { MY_HACK_BUTTONS: e.buttons });
                return evt;
            }
        }

        private static preventGlobalMouseEvents(): void {
            document.body.style.pointerEvents = 'none';
        }
        private static restoreGlobalMouseEvents(): void {
            document.body.style.pointerEvents = 'auto';
        }
        // #endregion
    }
}

class PointerPropertiesImpl implements
    Interaction.PointerProperties,
    Interaction.MousePointerProperties,
    Interaction.TouchPointerProperties,
    Interaction.PenPointerProperties {
    // MousePointerProperties
    buttons: Interaction.MouseButton;

    // PenPointerProperties
    isInContact: boolean;
}

class PointerEventImpl implements
    Interaction.IPointerEnterEvent,
    Interaction.IPointerExitEvent,
    Interaction.IPointerMoveEvent,
    Interaction.IPointerPressEvent,
    Interaction.IPointerReleaseEvent,
    Interaction.IPointerCaptureLostEvent,
    Interaction.IClickEvent,
    Interaction.ILongPressEvent {

    public handled: boolean = false;

    private m_type: Interaction.PointerDeviceType;
    public get type(): Interaction.PointerDeviceType {
        return this.m_type;
    }
    public set type(v: Interaction.PointerDeviceType) {
        this.m_type = v;
    }

    private m_mouseProperties: PointerPropertiesImpl = new PointerPropertiesImpl();
    public get properties(): PointerPropertiesImpl {
        return this.m_mouseProperties;
    }

    private m_capturing: boolean = false;
    public get capturing(): boolean {
        return this.m_capturing;
    }
    public set capturing(p: boolean) {
        this.m_capturing = p;
    }

    private m_position: THREE.Vector2;
    public get position(): THREE.Vector2 {
        return this.m_position;
    }
    public set position(p: THREE.Vector2) {
        this.m_position = p;
    }

    public intersection: THREE.Intersection;

    private m_click: number;
    public get count(): number {
        return this.m_click;
    }

    public incrementClickCount(): void {
        this.m_click += 1;
    }
    public resetClickCount(): void {
        this.m_click = 0;
    }
}

class ManipulationEventImpl implements
    Interaction.IManipulationStartEvent,
    Interaction.IManipulationDeltaEvent,
    Interaction.IManipulationEndEvent {

    private m_initialCenter: THREE.Vector2 = new THREE.Vector2(0, 0);
    private m_initialRotation: number;

    private m_sourceEvent: Interaction.IPointerEvent;
    private m_center: THREE.Vector2 = new THREE.Vector2(0, 0);
    private m_aggregatedMove: THREE.Vector2 = new THREE.Vector2(0, 0);
    private m_aggregatedScale: number;
    private m_aggregatedRotation: number;
    private m_deltaMove: THREE.Vector2 = new THREE.Vector2(0, 0);
    private m_deltaScale: number;
    private m_deltaRotation: number;

    constructor(sourceEvent: Interaction.IPointerEvent) {
        this.m_sourceEvent = sourceEvent;
    }

    public cancel: boolean = false;
    public get sourceEvent(): Interaction.IPointerEvent {
        return this.m_sourceEvent;
    }
    public get center(): THREE.Vector2 {
        return this.m_center;
    }
    public get aggregatedMove(): THREE.Vector2 {
        return this.m_aggregatedMove;
    }
    public get aggregatedScale(): number {
        return this.m_aggregatedScale;
    }
    public get aggregatedRotation(): number {
        return this.m_aggregatedRotation;
    }
    public get deltaMove(): THREE.Vector2 {
        return this.m_deltaMove;
    }
    public get deltaScale(): number {
        return this.m_deltaScale;
    }
    public get deltaRotation(): number {
        return this.m_deltaRotation;
    }

    public initialize(e: HammerInput, p: THREE.Vector2): void {
        this.cancel = false;
        this.m_initialCenter.set(p.x, p.y);
        this.m_center.set(p.x, p.y);
        this.m_initialRotation = e.rotation;
        this.m_aggregatedMove.set(0, 0);
        this.m_aggregatedScale = this.m_aggregatedRotation = 0;
        this.m_deltaMove.set(0, 0);
        this.m_deltaScale = this.m_deltaRotation = 0;
    }

    public update(e: HammerInput, p: THREE.Vector2): void {
        this.m_deltaMove.set(p.x - this.m_center.x, p.y - this.m_center.y);
        this.m_deltaScale = e.scale / this.m_aggregatedScale;
        this.m_deltaRotation = e.rotation - this.m_aggregatedRotation;
        this.m_aggregatedMove.set(p.x - this.m_initialCenter.x, p.y - this.m_initialCenter.y);
        this.m_aggregatedScale = e.scale;
        this.m_aggregatedRotation = e.rotation - this.m_initialRotation;
        this.m_center.set(p.x, p.y);
    }

    public changed(e: HammerInput, viewportPosition: THREE.Vector2): boolean {
        return !this.m_center.equals(viewportPosition)
            || this.m_aggregatedScale != e.scale
            || this.m_aggregatedRotation != (e.rotation - this.m_initialRotation);
    }
}

function getListener(i: Interaction.IThreeIntersection): Interaction.IThreeInteractionListener {
    return asListener(i.component);
}

function asListener(o: ThreeObject<any, any>): Interaction.IThreeInteractionListener {
    return (o as any).interactionListener;
}

function forEach<T>(iterator: IterableIterator<T>, func: (v: T) => boolean): boolean {
    for (let v of iterator) {
        if (func(v)) {
            return true;
        }
    }

    return false;
}
